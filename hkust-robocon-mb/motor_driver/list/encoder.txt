; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\encoder.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\encoder.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\FWlib\inc -I.\user -IC:\Users\BudiRyan\Documents\GitHub\robocon-2016\hkust-robocon-mb\motor_driver\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=516 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\encoder.crf user\encoder.c]
                          THUMB

                          AREA ||i.encoder_init||, CODE, READONLY, ALIGN=2

                  encoder_init PROC
;;;22     	*/
;;;23     void encoder_init(void)
000000  b510              PUSH     {r4,lr}
;;;24     {
000002  b088              SUB      sp,sp,#0x20
;;;25     	GPIO_InitTypeDef GPIO_InitStructure; 
;;;26     	TIM_TimeBaseInitTypeDef encoder_TIM_TimeBaseStructure;
;;;27     	TIM_ICInitTypeDef TIM_ICInitStructure;
;;;28     
;;;29     	/* GPIOA Configuration: TIM2 ch1, ch2, input float*/
;;;30     	encoder_gpio_rcc_init();
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;31     	
;;;32     	GPIO_InitStructure.GPIO_Pin = ENCODER_TIM_PORT1 | ENCODER_TIM_PORT2;
00000c  2003              MOVS     r0,#3
00000e  f8ad0018          STRH     r0,[sp,#0x18]
;;;33     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000012  2104              MOVS     r1,#4
000014  f88d101b          STRB     r1,[sp,#0x1b]
;;;34     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  f88d001a          STRB     r0,[sp,#0x1a]
;;;35     	GPIO_Init(ENCODER_TIM_GPIOx, &GPIO_InitStructure);
00001c  a906              ADD      r1,sp,#0x18
00001e  481d              LDR      r0,|L1.148|
000020  f7fffffe          BL       GPIO_Init
;;;36     
;;;37     	/* Timer configuration in Encoder mode */
;;;38     	encoder_rcc_init();
000024  2101              MOVS     r1,#1
000026  4608              MOV      r0,r1
000028  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;39     	
;;;40     	encoder_TIM_TimeBaseStructure.TIM_Prescaler = 0x0; // No prescaling
00002c  2000              MOVS     r0,#0
;;;41     	encoder_TIM_TimeBaseStructure.TIM_Period = 65535;
00002e  f64f71ff          MOV      r1,#0xffff
000032  f8ad1004          STRH     r1,[sp,#4]
000036  f8ad0000          STRH     r0,[sp,#0]            ;40
;;;42     	encoder_TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
00003a  f8ad0006          STRH     r0,[sp,#6]
;;;43     	encoder_TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
00003e  f8ad0002          STRH     r0,[sp,#2]
;;;44     	TIM_TimeBaseInit(ENCODER_TIM, &encoder_TIM_TimeBaseStructure);
000042  f04f4480          MOV      r4,#0x40000000
000046  4669              MOV      r1,sp
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       TIM_TimeBaseInit
;;;45     	
;;;46     	TIM_EncoderInterfaceConfig(ENCODER_TIM, TIM_EncoderMode_TI12,						//TIM_EncoderMode_TI12->count on 4 edge per cycle
00004e  2300              MOVS     r3,#0
000050  461a              MOV      r2,r3
000052  2103              MOVS     r1,#3
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       TIM_EncoderInterfaceConfig
;;;47     	                         TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
;;;48     	TIM_ICStructInit(&TIM_ICInitStructure);
00005a  a803              ADD      r0,sp,#0xc
00005c  f7fffffe          BL       TIM_ICStructInit
;;;49     	TIM_ICInitStructure.TIM_ICFilter = 8;
000060  2008              MOVS     r0,#8
000062  f8ad0014          STRH     r0,[sp,#0x14]
;;;50     	TIM_ICInit(ENCODER_TIM, &TIM_ICInitStructure);
000066  a903              ADD      r1,sp,#0xc
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       TIM_ICInit
;;;51     	
;;;52     	// Clear all pending interrupts
;;;53     	TIM_ClearFlag(ENCODER_TIM, TIM_FLAG_Update);
00006e  2101              MOVS     r1,#1
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       TIM_ClearFlag
;;;54     	TIM_ITConfig(ENCODER_TIM, TIM_IT_Update, ENABLE);
000076  2201              MOVS     r2,#1
000078  4611              MOV      r1,r2
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       TIM_ITConfig
;;;55     	// Reset counter to initial value
;;;56     	TIM_SetCounter(ENCODER_TIM, SOURCE_ENCODER_INIT_VAL);
000080  13e1              ASRS     r1,r4,#15
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       TIM_SetCounter
;;;57     	// Counter Enable
;;;58     	TIM_Cmd(ENCODER_TIM, ENABLE);
000088  2101              MOVS     r1,#1
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       TIM_Cmd
;;;59     }
000090  b008              ADD      sp,sp,#0x20
000092  bd10              POP      {r4,pc}
;;;60     
                          ENDP

                  |L1.148|
                          DCD      0x40010800

                          AREA ||i.encoder_update||, CODE, READONLY, ALIGN=2

                  encoder_update PROC
;;;65     	*/
;;;66     void encoder_update(void)
000000  b570              PUSH     {r4-r6,lr}
;;;67     {
;;;68     	static s32 flowing_flag = 0;						// -ve: no. of underflow, +ve: no. of overflow
;;;69     	static s32 prev_adjusted_encoder = 0;		// record data of past
;;;70     	
;;;71     	s32 source_encoder = TIM_GetCounter(ENCODER_TIM);	// value directly from timer count
000002  f04f4580          MOV      r5,#0x40000000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       TIM_GetCounter
;;;72     	if (source_encoder > 62768) {
00000c  f24f5130          MOV      r1,#0xf530
;;;73     		// Treat as underflow, add 30000 to timer counter.
;;;74     		TIM_SetCounter(ENCODER_TIM, source_encoder - 30000);
;;;75     		++flowing_flag;
000010  4c15              LDR      r4,|L2.104|
000012  4288              CMP      r0,r1                 ;72
000014  dd09              BLE      |L2.42|
000016  f5a040ea          SUB      r0,r0,#0x7500         ;72
00001a  3830              SUBS     r0,r0,#0x30           ;72
00001c  b281              UXTH     r1,r0                 ;74
00001e  4628              MOV      r0,r5                 ;74
000020  f7fffffe          BL       TIM_SetCounter
000024  68a0              LDR      r0,[r4,#8]  ; flowing_flag
000026  1c40              ADDS     r0,r0,#1
000028  e00b              B        |L2.66|
                  |L2.42|
;;;76     	} else if (source_encoder < 2768) {
00002a  f5b06f2d          CMP      r0,#0xad0
00002e  da09              BGE      |L2.68|
;;;77     		// Treat as underflow, add 30000 to timer counter.
;;;78     		TIM_SetCounter(ENCODER_TIM, source_encoder + 30000);
000030  f2475130          MOV      r1,#0x7530
000034  4408              ADD      r0,r0,r1
000036  b281              UXTH     r1,r0
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       TIM_SetCounter
;;;79     		--flowing_flag;
00003e  68a0              LDR      r0,[r4,#8]  ; flowing_flag
000040  1e40              SUBS     r0,r0,#1
                  |L2.66|
000042  60a0              STR      r0,[r4,#8]  ; flowing_flag
                  |L2.68|
;;;80     	}
;;;81     
;;;82     	adjusted_encoder = flowing_flag * 30000 + TIM_GetCounter(ENCODER_TIM) - SOURCE_ENCODER_INIT_VAL;
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       TIM_GetCounter
00004a  68a1              LDR      r1,[r4,#8]  ; flowing_flag
00004c  f2407253          MOV      r2,#0x753
000050  4351              MULS     r1,r2,r1
000052  eb001001          ADD      r0,r0,r1,LSL #4
000056  f5a04000          SUB      r0,r0,#0x8000
;;;83     
;;;84     	rate_change_encoder = -adjusted_encoder + prev_adjusted_encoder;
00005a  6020              STR      r0,[r4,#0]  ; adjusted_encoder
00005c  68e1              LDR      r1,[r4,#0xc]  ; prev_adjusted_encoder
00005e  1a09              SUBS     r1,r1,r0
;;;85     	prev_adjusted_encoder = adjusted_encoder;
000060  6061              STR      r1,[r4,#4]  ; rate_change_encoder
000062  60e0              STR      r0,[r4,#0xc]  ; prev_adjusted_encoder
;;;86     }
000064  bd70              POP      {r4-r6,pc}
;;;87     
                          ENDP

000066  0000              DCW      0x0000
                  |L2.104|
                          DCD      ||.data||

                          AREA ||i.get_encoder||, CODE, READONLY, ALIGN=2

                  get_encoder PROC
;;;92     	*/
;;;93     s32 get_encoder(void)
000000  4801              LDR      r0,|L3.8|
;;;94     {
;;;95     	return adjusted_encoder;
000002  6800              LDR      r0,[r0,#0]  ; adjusted_encoder
;;;96     }
000004  4770              BX       lr
;;;97     
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.get_encoder_vel||, CODE, READONLY, ALIGN=2

                  get_encoder_vel PROC
;;;101    	*/
;;;102    s32 get_encoder_vel(void)
000000  4801              LDR      r0,|L4.8|
;;;103    {
;;;104    	return rate_change_encoder;
000002  6840              LDR      r0,[r0,#4]  ; rate_change_encoder
;;;105    }
000004  4770              BX       lr
;;;106    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  adjusted_encoder
                          DCD      0x00000000
                  rate_change_encoder
                          DCD      0x00000000
                  flowing_flag
                          DCD      0x00000000
                  prev_adjusted_encoder
                          DCD      0x00000000
