; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\velocity.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\velocity.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\FWlib\inc -I.\user -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=516 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\velocity.crf user\velocity.c]
                          THUMB

                          AREA ||i.cal_vel_err||, CODE, READONLY, ALIGN=2

                  cal_vel_err PROC
;;;124    	*/
;;;125    static s32 cal_vel_err(void)
000000  b510              PUSH     {r4,lr}
;;;126    {
;;;127    	 return current_vel - get_encoder_vel();
000002  f7fffffe          BL       get_encoder_vel
000006  4902              LDR      r1,|L1.16|
000008  6849              LDR      r1,[r1,#4]  ; current_vel
00000a  1a08              SUBS     r0,r1,r0
;;;128    }
00000c  bd10              POP      {r4,pc}
;;;129    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      ||.data||

                          AREA ||i.get_curr_loop_flag||, CODE, READONLY, ALIGN=2

                  get_curr_loop_flag PROC
;;;154    	*/
;;;155    CLOSE_LOOP_FLAG get_curr_loop_flag(void)
000000  4801              LDR      r0,|L2.8|
;;;156    {
;;;157    	return current_flag;
000002  7800              LDRB     r0,[r0,#0]  ; current_flag
;;;158    }
000004  4770              BX       lr
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.get_current_accel||, CODE, READONLY, ALIGN=2

                  get_current_accel PROC
;;;144    	*/
;;;145    u16 get_current_accel(void)
000000  4801              LDR      r0,|L3.8|
;;;146    {
;;;147    	return current_accel;
000002  8840              LDRH     r0,[r0,#2]  ; current_accel
;;;148    }
000004  4770              BX       lr
;;;149    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.get_target_vel||, CODE, READONLY, ALIGN=2

                  get_target_vel PROC
;;;134    	*/
;;;135    s32 get_target_vel(void)
000000  4801              LDR      r0,|L4.8|
;;;136    {
;;;137    	return target_vel;
000002  6880              LDR      r0,[r0,#8]  ; target_vel
;;;138    }
000004  4770              BX       lr
;;;139    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.data||

                          AREA ||i.lock_motor||, CODE, READONLY, ALIGN=2

                  lock_motor PROC
;;;70     	*/
;;;71     void lock_motor(void)
000000  4802              LDR      r0,|L5.12|
;;;72     {
;;;73     	current_vel = target_vel = 0;
000002  2100              MOVS     r1,#0
000004  6081              STR      r1,[r0,#8]  ; target_vel
000006  6041              STR      r1,[r0,#4]  ; current_vel
;;;74     }
000008  4770              BX       lr
;;;75     
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      ||.data||

                          AREA ||i.motor_control||, CODE, READONLY, ALIGN=2

                  motor_control PROC
;;;96     	*/
;;;97     void motor_control(s32 p, s32 i, s32 d)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;98     {
000004  4690              MOV      r8,r2
000006  460d              MOV      r5,r1
000008  4606              MOV      r6,r0
;;;99     	static s32 prev_error = 0;
;;;100    	static s32 last_prev_error = 0;
;;;101    	const u16 PID_Prescalar = 100;		// All PID's value are multiplyed by 100
;;;102    	s32 PID = p*(cal_vel_err() - prev_error) + i*cal_vel_err() + d*(cal_vel_err() + last_prev_error - prev_error*2);
00000a  f7fffffe          BL       cal_vel_err
00000e  4c15              LDR      r4,|L6.100|
000010  6921              LDR      r1,[r4,#0x10]  ; prev_error
000012  1a47              SUBS     r7,r0,r1
000014  4377              MULS     r7,r6,r7
000016  f7fffffe          BL       cal_vel_err
00001a  fb057500          MLA      r5,r5,r0,r7
00001e  f7fffffe          BL       cal_vel_err
000022  6961              LDR      r1,[r4,#0x14]  ; last_prev_error
000024  4408              ADD      r0,r0,r1
000026  6921              LDR      r1,[r4,#0x10]  ; prev_error
000028  4249              RSBS     r1,r1,#0
00002a  eb000141          ADD      r1,r0,r1,LSL #1
00002e  fb085001          MLA      r0,r8,r1,r5
;;;103    	PID /= PID_Prescalar;
000032  2164              MOVS     r1,#0x64
000034  fb90f0f1          SDIV     r0,r0,r1
;;;104    	
;;;105    	// Disable PID control if open loop
;;;106    	if (current_flag == CLOSE_LOOP) {
000038  7821              LDRB     r1,[r4,#0]  ; current_flag
00003a  2901              CMP      r1,#1
00003c  d00d              BEQ      |L6.90|
;;;107    		curr_pwm += PID;
;;;108    	} else {
;;;109    		// No PID control velocity, velocity will be the differentiate of encoder value.
;;;110    		target_vel = current_vel = get_encoder_vel();
00003e  f7fffffe          BL       get_encoder_vel
000042  6060              STR      r0,[r4,#4]  ; current_vel
000044  60a0              STR      r0,[r4,#8]  ; target_vel
                  |L6.70|
;;;111    	}
;;;112    	
;;;113    	last_prev_error = prev_error;
000046  6920              LDR      r0,[r4,#0x10]  ; prev_error
;;;114    	prev_error = cal_vel_err();
000048  6160              STR      r0,[r4,#0x14]  ; last_prev_error
00004a  f7fffffe          BL       cal_vel_err
;;;115    	
;;;116    	// set pwm here.
;;;117    	motor_set_pwm(curr_pwm);
00004e  6120              STR      r0,[r4,#0x10]  ; prev_error
000050  68e0              LDR      r0,[r4,#0xc]  ; curr_pwm
000052  e8bd41f0          POP      {r4-r8,lr}
000056  f7ffbffe          B.W      motor_set_pwm
                  |L6.90|
00005a  68e1              LDR      r1,[r4,#0xc]          ;107  ; curr_pwm
00005c  4408              ADD      r0,r0,r1              ;107
00005e  60e0              STR      r0,[r4,#0xc]          ;107  ; curr_pwm
000060  e7f1              B        |L6.70|
;;;118    }
;;;119    
                          ENDP

000062  0000              DCW      0x0000
                  |L6.100|
                          DCD      ||.data||

                          AREA ||i.set_acceleration||, CODE, READONLY, ALIGN=2

                  set_acceleration PROC
;;;32     	*/
;;;33     void set_acceleration(u16 a)
000000  2802              CMP      r0,#2
;;;34     {
000002  d201              BCS      |L7.8|
;;;35     	// Minimum acceleration
;;;36     	if (a < MINIMUM_ACCEL) {
;;;37     		a = MINIMUM_ACCEL;
000004  2002              MOVS     r0,#2
000006  e004              B        |L7.18|
                  |L7.8|
;;;38     	} else if (a > MAXIMUM_ACCEL) {
000008  f44f717a          MOV      r1,#0x3e8
00000c  4288              CMP      r0,r1
00000e  d900              BLS      |L7.18|
;;;39     		a = MAXIMUM_ACCEL;
000010  4608              MOV      r0,r1
                  |L7.18|
;;;40     	}
;;;41     	current_accel = a;
000012  4901              LDR      r1,|L7.24|
000014  8048              STRH     r0,[r1,#2]
;;;42     }
000016  4770              BX       lr
;;;43     
                          ENDP

                  |L7.24|
                          DCD      ||.data||

                          AREA ||i.set_pwm||, CODE, READONLY, ALIGN=2

                  set_pwm PROC
;;;59     	*/
;;;60     void set_pwm(s32 pwm)
000000  4902              LDR      r1,|L8.12|
;;;61     {
;;;62     	curr_pwm = pwm;	
;;;63     	current_flag = OPEN_LOOP;
000002  60c8              STR      r0,[r1,#0xc]  ; curr_pwm
000004  2000              MOVS     r0,#0
000006  7008              STRB     r0,[r1,#0]
;;;64     }
000008  4770              BX       lr
;;;65     
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      ||.data||

                          AREA ||i.set_velocity||, CODE, READONLY, ALIGN=2

                  set_velocity PROC
;;;48     	*/
;;;49     void set_velocity(s32 vel)
000000  4902              LDR      r1,|L9.12|
;;;50     {
;;;51     	target_vel = vel;
;;;52     	current_flag = CLOSE_LOOP;
000002  6088              STR      r0,[r1,#8]  ; target_vel
000004  2001              MOVS     r0,#1
000006  7008              STRB     r0,[r1,#0]
;;;53     }
000008  4770              BX       lr
;;;54     
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      ||.data||

                          AREA ||i.velocity_update||, CODE, READONLY, ALIGN=2

                  velocity_update PROC
;;;83     	*/
;;;84     void velocity_update(void)
000000  4806              LDR      r0,|L10.28|
;;;85     {
;;;86     	if (current_vel > target_vel) {
000002  e9d01201          LDRD     r1,r2,[r0,#4]
000006  4291              CMP      r1,r2
000008  dd02              BLE      |L10.16|
00000a  f1a10101          SUB      r1,r1,#1
;;;87     		--current_vel;	// decel
00000e  e002              B        |L10.22|
                  |L10.16|
;;;88     	} else if (current_vel < target_vel) {
000010  da02              BGE      |L10.24|
000012  f1010101          ADD      r1,r1,#1
                  |L10.22|
000016  6041              STR      r1,[r0,#4]            ;87  ; current_vel
                  |L10.24|
;;;89     		++current_vel;	// accel
;;;90     	}
;;;91     }
000018  4770              BX       lr
;;;92     /**
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  current_flag
000000  0000              DCB      0x00,0x00
                  current_accel
000002  0064              DCW      0x0064
                  current_vel
                          DCD      0x00000000
                  target_vel
                          DCD      0x00000000
                  curr_pwm
                          DCD      0x00000000
                  prev_error
                          DCD      0x00000000
                  last_prev_error
                          DCD      0x00000000
