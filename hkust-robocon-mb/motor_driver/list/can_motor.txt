; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\can_motor.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\can_motor.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\FWlib\inc -I.\user -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=516 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\can_motor.crf user\can_motor.c]
                          THUMB

                          AREA ||i.can_motor_feedback_encoder||, CODE, READONLY, ALIGN=2

                  can_motor_feedback_encoder PROC
;;;169    /** These are how mainboard receive data, keep here for reference ONLY **/
;;;170    void can_motor_feedback_encoder(CanRxMsg msg)
000000  b40f              PUSH     {r0-r3}
;;;171    {
000002  b510              PUSH     {r4,lr}
;;;172    	switch (msg.Data[0]) {
000004  f89d0013          LDRB     r0,[sp,#0x13]
000008  2822              CMP      r0,#0x22
00000a  d113              BNE      |L1.52|
;;;173    		case CAN_ENCODER_FEEDBACK:
;;;174    			if (msg.DLC == CAN_ENCODER_FEEDBACK_LENGTH) {
00000c  f89d0012          LDRB     r0,[sp,#0x12]
000010  2805              CMP      r0,#5
000012  d10f              BNE      |L1.52|
;;;175    				// Range check 
;;;176    				if (msg.StdId >= CAN_MOTOR_BASE && msg.StdId < CAN_MOTOR_BASE + CAN_MOTOR_COUNT) {
000014  9802              LDR      r0,[sp,#8]
000016  38b0              SUBS     r0,r0,#0xb0
000018  2810              CMP      r0,#0x10
00001a  d20b              BCS      |L1.52|
;;;177    					s32 feedback = n_bytes_to_one(&msg.Data[1], 4);
00001c  2104              MOVS     r1,#4
00001e  a805              ADD      r0,sp,#0x14
000020  f7fffffe          BL       n_bytes_to_one
;;;178    					can_motor_encoder_value[msg.StdId - CAN_MOTOR_BASE] = feedback;
000024  4a05              LDR      r2,|L1.60|
000026  9902              LDR      r1,[sp,#8]
000028  eb020181          ADD      r1,r2,r1,LSL #2
00002c  f5a15180          SUB      r1,r1,#0x1000
000030  f8c10d40          STR      r0,[r1,#0xd40]
                  |L1.52|
;;;179    				}
;;;180    			}
;;;181    		break;
;;;182    	}
;;;183    }
000034  bc10              POP      {r4}
000036  f85dfb14          LDR      pc,[sp],#0x14
;;;184    
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      ||.bss||

                          AREA ||i.can_motor_init||, CODE, READONLY, ALIGN=2

                  can_motor_init PROC
;;;5      
;;;6      void can_motor_init(void)
000000  4a02              LDR      r2,|L2.12|
;;;7      {
;;;8      	can_rx_add_filter(get_can_motor_id(this_motor), CAN_RX_MASK_EXACT, 	motor_cmd_decoding);
000002  f24071ff          MOV      r1,#0x7ff
000006  20b1              MOVS     r0,#0xb1
000008  f7ffbffe          B.W      can_rx_add_filter
;;;9      }
;;;10     
                          ENDP

                  |L2.12|
                          DCD      motor_cmd_decoding

                          AREA ||i.get_encoder_value||, CODE, READONLY, ALIGN=2

                  get_encoder_value PROC
;;;184    
;;;185    s32 get_encoder_value(MOTOR_ID motor_id)
000000  4901              LDR      r1,|L3.8|
;;;186    {
;;;187    	return can_motor_encoder_value[motor_id];
000002  f8510020          LDR      r0,[r1,r0,LSL #2]
;;;188    }
000006  4770              BX       lr
;;;189    
                          ENDP

                  |L3.8|
                          DCD      ||.bss||

                          AREA ||i.motor_cmd_decoding||, CODE, READONLY, ALIGN=1

                  motor_cmd_decoding PROC
;;;125    /*** motor command decoding ***/
;;;126    void motor_cmd_decoding(CanRxMsg msg)
000000  b40f              PUSH     {r0-r3}
;;;127    {
;;;128    	switch (msg.Data[0]) {
000002  2200              MOVS     r2,#0
000004  b538              PUSH     {r3-r5,lr}            ;127
000006  a904              ADD      r1,sp,#0x10
000008  f89d301b          LDRB     r3,[sp,#0x1b]
;;;129    		case CAN_MOTOR_VEL_CMD:
;;;130    			if (msg.DLC == CAN_MOTOR_VEL_LENGTH) {
00000c  f89d001a          LDRB     r0,[sp,#0x1a]
000010  2b44              CMP      r3,#0x44              ;128
000012  d032              BEQ      |L4.122|
000014  2baa              CMP      r3,#0xaa              ;128
000016  d00a              BEQ      |L4.46|
000018  2bbb              CMP      r3,#0xbb              ;128
00001a  d028              BEQ      |L4.110|
00001c  2bee              CMP      r3,#0xee              ;128
00001e  d126              BNE      |L4.110|
;;;131    				const u8 VEL_SIZE = 4;	// velocity data contain 4 bytes
;;;132    				u8 fragment_vel[VEL_SIZE] = {0};
;;;133    				for (u8 i = 0; i < VEL_SIZE; ++i) {
;;;134    					fragment_vel[i] = msg.Data[i+1];
;;;135    				}
;;;136    				CLOSE_LOOP_FLAG loop_flag = (CLOSE_LOOP_FLAG) msg.Data[5];// 5-th byte is loop-flag (start as 0th byte)
;;;137    				// velocity or pwm control.
;;;138    				s32 velocity = n_bytes_to_one(fragment_vel, VEL_SIZE);
;;;139    				// Ignore if same velocity is sent.
;;;140    				if (velocity != get_target_vel() || loop_flag != get_curr_loop_flag()) {
;;;141    					(loop_flag == CLOSE_LOOP) ? set_velocity(velocity) : set_pwm(velocity);
;;;142    				}
;;;143    			}
;;;144    			break;
;;;145    		case CAN_MOTOR_ACCEL_CMD:
;;;146    			if (msg.DLC == CAN_MOTOR_ACCEL_LENGTH) {
;;;147    				const u8 ACCEL_SIZE = 2;	// acceleration data contain 2 bytes
;;;148    				u8 fragment_accel[ACCEL_SIZE] = {0};
;;;149    				for (u8 i = 0; i < ACCEL_SIZE; ++i) {
;;;150    					fragment_accel[i] = msg.Data[i+1];
;;;151    				}
;;;152    				set_acceleration(n_bytes_to_one(fragment_accel, ACCEL_SIZE));
;;;153    			}
;;;154    			break;
;;;155    		case CAN_MOTOR_POS_CMD:
;;;156    			// Coming Soon.
;;;157    			break;
;;;158    		case CAN_MOTOR_LOCK_CMD:
;;;159    			if (msg.DLC == CAN_MOTOR_LOCK_LENGTH) {
000020  2801              CMP      r0,#1
000022  d124              BNE      |L4.110|
;;;160    				lock_motor();
000024  bc38              POP      {r3-r5}
000026  f85deb14          LDR      lr,[sp],#0x14
00002a  f7ffbffe          B.W      lock_motor
                  |L4.46|
00002e  2806              CMP      r0,#6                 ;130
000030  d11d              BNE      |L4.110|
000032  9200              STR      r2,[sp,#0]            ;132
000034  2000              MOVS     r0,#0                 ;133
000036  466a              MOV      r2,sp                 ;132
                  |L4.56|
000038  180b              ADDS     r3,r1,r0              ;134
00003a  7b1b              LDRB     r3,[r3,#0xc]          ;134
00003c  5413              STRB     r3,[r2,r0]            ;134
00003e  1c40              ADDS     r0,r0,#1              ;134
000040  b2c0              UXTB     r0,r0                 ;133
000042  2804              CMP      r0,#4                 ;133
000044  d3f8              BCC      |L4.56|
000046  f89d5020          LDRB     r5,[sp,#0x20]         ;136
00004a  2104              MOVS     r1,#4                 ;138
00004c  4610              MOV      r0,r2                 ;138
00004e  f7fffffe          BL       n_bytes_to_one
000052  4604              MOV      r4,r0                 ;138
000054  f7fffffe          BL       get_target_vel
000058  42a0              CMP      r0,r4                 ;140
00005a  d103              BNE      |L4.100|
00005c  f7fffffe          BL       get_curr_loop_flag
000060  42a8              CMP      r0,r5                 ;140
000062  d004              BEQ      |L4.110|
                  |L4.100|
000064  2d01              CMP      r5,#1                 ;141
000066  4620              MOV      r0,r4                 ;141
000068  d004              BEQ      |L4.116|
00006a  f7fffffe          BL       set_pwm
                  |L4.110|
;;;161    			}
;;;162    			break;
;;;163    		default:
;;;164    			return;
;;;165    	}
;;;166    }
00006e  bc38              POP      {r3-r5}
000070  f85dfb14          LDR      pc,[sp],#0x14
                  |L4.116|
000074  f7fffffe          BL       set_velocity
000078  e7f9              B        |L4.110|
                  |L4.122|
00007a  2803              CMP      r0,#3                 ;146
00007c  d1f7              BNE      |L4.110|
00007e  9200              STR      r2,[sp,#0]            ;148
000080  2000              MOVS     r0,#0                 ;149
000082  466a              MOV      r2,sp                 ;148
                  |L4.132|
000084  180b              ADDS     r3,r1,r0              ;150
000086  7b1b              LDRB     r3,[r3,#0xc]          ;150
000088  5413              STRB     r3,[r2,r0]            ;150
00008a  1c40              ADDS     r0,r0,#1              ;150
00008c  b2c0              UXTB     r0,r0                 ;149
00008e  2802              CMP      r0,#2                 ;149
000090  d3f8              BCC      |L4.132|
000092  2102              MOVS     r1,#2                 ;152
000094  4610              MOV      r0,r2                 ;152
000096  f7fffffe          BL       n_bytes_to_one
00009a  b280              UXTH     r0,r0                 ;152
00009c  f7fffffe          BL       set_acceleration
0000a0  e7e5              B        |L4.110|
;;;167    
                          ENDP


                          AREA ||i.motor_lock||, CODE, READONLY, ALIGN=1

                  motor_lock PROC
;;;108    	*/
;;;109    void motor_lock(MOTOR_ID motor_id)
000000  b430              PUSH     {r4,r5}
;;;110    {
;;;111    	CAN_MESSAGE msg;
;;;112    	
;;;113    	assert_param((u8)motor_id < CAN_MOTOR_COUNT);
;;;114    	
;;;115    	msg.id = get_can_motor_id(motor_id);
;;;116    	msg.length = CAN_MOTOR_LOCK_LENGTH;
000002  2401              MOVS     r4,#1
000004  f3640107          BFI      r1,r4,#0,#8
;;;117    	msg.data[0] = CAN_MOTOR_LOCK_CMD;
000008  24ee              MOVS     r4,#0xee
00000a  f364210f          BFI      r1,r4,#8,#8
;;;118    
;;;119    	can_tx_enqueue(msg);
00000e  bc30              POP      {r4,r5}
000010  30b0              ADDS     r0,r0,#0xb0           ;117
000012  f7ffbffe          B.W      can_tx_enqueue
;;;120    }
;;;121    /*** End of TX ***/
                          ENDP


                          AREA ||i.motor_set_acceleration||, CODE, READONLY, ALIGN=1

                  motor_set_acceleration PROC
;;;88     	*/
;;;89     void motor_set_acceleration(MOTOR_ID motor_id, u16 accel)
000000  b570              PUSH     {r4-r6,lr}
;;;90     {
000002  f10005b0          ADD      r5,r0,#0xb0
;;;91     	CAN_MESSAGE msg;
;;;92     	
;;;93     	assert_param((u8)motor_id < CAN_MOTOR_COUNT);
;;;94     	
;;;95     	msg.id = get_can_motor_id(motor_id);
;;;96     	msg.length = CAN_MOTOR_ACCEL_LENGTH;
000006  2003              MOVS     r0,#3
000008  f3600407          BFI      r4,r0,#0,#8
00000c  460e              MOV      r6,r1                 ;90
;;;97     	msg.data[0] = CAN_MOTOR_ACCEL_CMD;
00000e  2044              MOVS     r0,#0x44
000010  f360240f          BFI      r4,r0,#8,#8
;;;98     	msg.data[1] = (u8)(one_to_n_bytes(accel, 0));
000014  2100              MOVS     r1,#0
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       one_to_n_bytes
00001c  f3604417          BFI      r4,r0,#16,#8
;;;99     	msg.data[2] = (u8)(one_to_n_bytes(accel, 1));
000020  2101              MOVS     r1,#1
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       one_to_n_bytes
000028  f360641f          BFI      r4,r0,#24,#8
;;;100    
;;;101    	can_tx_enqueue(msg);
00002c  4633              MOV      r3,r6
00002e  4621              MOV      r1,r4
000030  4628              MOV      r0,r5
000032  e8bd4070          POP      {r4-r6,lr}
000036  461a              MOV      r2,r3
000038  f7ffbffe          B.W      can_tx_enqueue
;;;102    }
;;;103    
                          ENDP


                          AREA ||i.motor_set_pos||, CODE, READONLY, ALIGN=1

                  motor_set_pos PROC
;;;63     	*/
;;;64     void motor_set_pos(MOTOR_ID motor_id, u16 vel, s32 pos)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;65     {
000004  f10006b0          ADD      r6,r0,#0xb0
;;;66     	CAN_MESSAGE msg;
;;;67     	
;;;68     	assert_param((u8)motor_id < CAN_MOTOR_COUNT);
;;;69     	
;;;70     	msg.id = get_can_motor_id(motor_id);
;;;71     	msg.length = CAN_MOTOR_POS_LENGTH;
000008  2007              MOVS     r0,#7
00000a  f3600407          BFI      r4,r0,#0,#8
00000e  460d              MOV      r5,r1                 ;65
;;;72     	msg.data[0] = CAN_MOTOR_POS_CMD;
000010  20bb              MOVS     r0,#0xbb
000012  f360240f          BFI      r4,r0,#8,#8
000016  4617              MOV      r7,r2                 ;65
;;;73     	msg.data[1] = (u8)(one_to_n_bytes(vel, 0));
000018  2100              MOVS     r1,#0
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       one_to_n_bytes
000020  f3604417          BFI      r4,r0,#16,#8
;;;74     	msg.data[2] = (u8)(one_to_n_bytes(vel, 1));
000024  2101              MOVS     r1,#1
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       one_to_n_bytes
00002c  f360641f          BFI      r4,r0,#24,#8
;;;75     	msg.data[3] = (u8)(one_to_n_bytes(pos, 0));
000030  2100              MOVS     r1,#0
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       one_to_n_bytes
000038  f3600507          BFI      r5,r0,#0,#8
;;;76     	msg.data[4] = (u8)(one_to_n_bytes(pos, 1));
00003c  2101              MOVS     r1,#1
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       one_to_n_bytes
000044  f360250f          BFI      r5,r0,#8,#8
;;;77     	msg.data[5] = (u8)(one_to_n_bytes(pos, 2));
000048  2102              MOVS     r1,#2
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       one_to_n_bytes
000050  f3604517          BFI      r5,r0,#16,#8
;;;78     	msg.data[6] = (u8)(one_to_n_bytes(pos, 3));
000054  2103              MOVS     r1,#3
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       one_to_n_bytes
00005c  462a              MOV      r2,r5
00005e  f360621f          BFI      r2,r0,#24,#8
;;;79     
;;;80     	can_tx_enqueue(msg);
000062  463b              MOV      r3,r7
000064  4621              MOV      r1,r4
000066  4630              MOV      r0,r6
000068  e8bd41f0          POP      {r4-r8,lr}
00006c  f7ffbffe          B.W      can_tx_enqueue
;;;81     }
;;;82     
                          ENDP


                          AREA ||i.motor_set_vel||, CODE, READONLY, ALIGN=1

                  motor_set_vel PROC
;;;38     	*/
;;;39     void motor_set_vel(MOTOR_ID motor_id, s32 vel, CLOSE_LOOP_FLAG close_loop_flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;40     {
000004  f10006b0          ADD      r6,r0,#0xb0
;;;41     	CAN_MESSAGE msg;
;;;42     	
;;;43     	assert_param((u8)motor_id < CAN_MOTOR_COUNT);
;;;44     
;;;45     	msg.id = get_can_motor_id(motor_id);
;;;46     	msg.length = CAN_MOTOR_VEL_LENGTH;
000008  2006              MOVS     r0,#6
00000a  f3600407          BFI      r4,r0,#0,#8
00000e  4688              MOV      r8,r1                 ;40
;;;47     	msg.data[0] = CAN_MOTOR_VEL_CMD;
000010  20aa              MOVS     r0,#0xaa
000012  f360240f          BFI      r4,r0,#8,#8
000016  4617              MOV      r7,r2                 ;40
;;;48     	msg.data[1] = (u8)(one_to_n_bytes(vel, 0));
000018  2100              MOVS     r1,#0
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       one_to_n_bytes
000020  f3604417          BFI      r4,r0,#16,#8
;;;49     	msg.data[2] = (u8)(one_to_n_bytes(vel, 1));
000024  2101              MOVS     r1,#1
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       one_to_n_bytes
00002c  f360641f          BFI      r4,r0,#24,#8
;;;50     	msg.data[3] = (u8)(one_to_n_bytes(vel, 2));
000030  2102              MOVS     r1,#2
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       one_to_n_bytes
000038  f3600507          BFI      r5,r0,#0,#8
;;;51     	msg.data[4] = (u8)(one_to_n_bytes(vel, 3));
00003c  2103              MOVS     r1,#3
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       one_to_n_bytes
000044  f360250f          BFI      r5,r0,#8,#8
000048  462a              MOV      r2,r5
00004a  f3674217          BFI      r2,r7,#16,#8
;;;52     	msg.data[5] = (u8)(close_loop_flag);
;;;53     	
;;;54     	can_tx_enqueue(msg);
00004e  4643              MOV      r3,r8
000050  4621              MOV      r1,r4
000052  4630              MOV      r0,r6
000054  e8bd41f0          POP      {r4-r8,lr}
000058  f7ffbffe          B.W      can_tx_enqueue
;;;55     }
;;;56     
                          ENDP


                          AREA ||i.send_encoder||, CODE, READONLY, ALIGN=1

                  send_encoder PROC
;;;16     	*/
;;;17     void send_encoder(s32 encoder_value)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;18     {
000004  4607              MOV      r7,r0
;;;19     	CAN_MESSAGE msg;
;;;20     	msg.id = get_can_motor_id(this_motor);
;;;21     	msg.length = CAN_ENCODER_FEEDBACK_LENGTH;
000006  2005              MOVS     r0,#5
000008  f3600407          BFI      r4,r0,#0,#8
;;;22     	msg.data[0] = CAN_ENCODER_FEEDBACK;
00000c  2022              MOVS     r0,#0x22
00000e  f360240f          BFI      r4,r0,#8,#8
000012  26b1              MOVS     r6,#0xb1              ;20
;;;23     	msg.data[1] = one_to_n_bytes(encoder_value,0);
000014  2100              MOVS     r1,#0
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       one_to_n_bytes
00001c  f3604417          BFI      r4,r0,#16,#8
;;;24     	msg.data[2] = one_to_n_bytes(encoder_value,1);
000020  2101              MOVS     r1,#1
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       one_to_n_bytes
000028  f360641f          BFI      r4,r0,#24,#8
;;;25     	msg.data[3] = one_to_n_bytes(encoder_value,2);
00002c  2102              MOVS     r1,#2
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       one_to_n_bytes
000034  f3600507          BFI      r5,r0,#0,#8
;;;26     	msg.data[4] = one_to_n_bytes(encoder_value,3);
000038  2103              MOVS     r1,#3
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       one_to_n_bytes
000040  462a              MOV      r2,r5
000042  f360220f          BFI      r2,r0,#8,#8
;;;27     	can_tx_enqueue(msg);
000046  463b              MOV      r3,r7
000048  4621              MOV      r1,r4
00004a  4630              MOV      r0,r6
00004c  e8bd41f0          POP      {r4-r8,lr}
000050  f7ffbffe          B.W      can_tx_enqueue
;;;28     }
;;;29     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  can_motor_encoder_value
                          %        64
