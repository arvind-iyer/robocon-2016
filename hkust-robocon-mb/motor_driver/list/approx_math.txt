; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\approx_math.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\approx_math.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\FWlib\inc -I.\user -IC:\Users\BudiRyan\Documents\GitHub\robocon-2016\hkust-robocon-mb\motor_driver\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=516 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\approx_math.crf user\approx_math.c]
                          THUMB

                          AREA ||i.Abs||, CODE, READONLY, ALIGN=1

                  Abs PROC
;;;219      */
;;;220    s32 Abs(s32 v)
000000  2800              CMP      r0,#0
;;;221    {
000002  da00              BGE      |L1.6|
;;;222    	return v < 0 ? -v : v;
000004  4240              RSBS     r0,r0,#0
                  |L1.6|
;;;223    }
000006  4770              BX       lr
;;;224    
                          ENDP


                          AREA ||i.Sqr||, CODE, READONLY, ALIGN=1

                  ||Sqr|| PROC
;;;228    
;;;229    s32 Sqr (s32 x) {
000000  4340              MULS     r0,r0,r0
;;;230    	return x * x;
;;;231    }
000002  4770              BX       lr
;;;232    
                          ENDP


                          AREA ||i.Sqrt||, CODE, READONLY, ALIGN=1

                  Sqrt PROC
;;;237      */
;;;238    s32 Sqrt(s32 num) {
000000  b530              PUSH     {r4,r5,lr}
000002  0003              MOVS     r3,r0
;;;239    	s32 upper_sqrt = 1, lower_sqrt, range, tmp_sqrt, tmp_sqr;
000004  f04f0001          MOV      r0,#1
000008  d002              BEQ      |L3.16|
00000a  e003              B        |L3.20|
                  |L3.12|
;;;240    	//u8 i = 0;
;;;241    	if (num == 0) return 0;
;;;242    
;;;243    	while (Sqr(upper_sqrt) <= num) {
;;;244    		if ((upper_sqrt <<= 1) < 0) {
00000c  0040              LSLS     r0,r0,#1
00000e  d501              BPL      |L3.20|
                  |L3.16|
;;;245    			return 0;	// Overflow happened
000010  2000              MOVS     r0,#0
                  |L3.18|
;;;246    		}
;;;247    	}
;;;248    
;;;249    	lower_sqrt = upper_sqrt >> 1;
;;;250    	range = upper_sqrt - lower_sqrt;
;;;251    	do {
;;;252    		tmp_sqrt = lower_sqrt + (range >>= 1);
;;;253    		tmp_sqr = Sqr(tmp_sqrt);
;;;254    		if (tmp_sqr < num) {lower_sqrt = tmp_sqrt;}
;;;255    		else if (tmp_sqr > num) {upper_sqrt = tmp_sqrt;}
;;;256    		else {return tmp_sqrt;}
;;;257    		//printf("%d to %d \n", lower_sqrt, upper_sqrt);
;;;258    	} while (range >= 2);
;;;259    
;;;260    	//printf("%d, %d\n", num, (Sqr(lower_sqrt) + Sqr(upper_sqrt)) >> 1);
;;;261    	if (num < (Sqr(lower_sqrt) + Sqr(upper_sqrt)) >> 1) {
;;;262    		return lower_sqrt;
;;;263    	} else {
;;;264    		return upper_sqrt;
;;;265    	}
;;;266    }
000012  bd30              POP      {r4,r5,pc}
                  |L3.20|
000014  fb00f100          MUL      r1,r0,r0              ;243
000018  4299              CMP      r1,r3                 ;243
00001a  ddf7              BLE      |L3.12|
00001c  1041              ASRS     r1,r0,#1              ;249
00001e  1a44              SUBS     r4,r0,r1              ;250
                  |L3.32|
000020  1064              ASRS     r4,r4,#1              ;252
000022  1862              ADDS     r2,r4,r1              ;252
000024  fb02f502          MUL      r5,r2,r2              ;253
000028  429d              CMP      r5,r3                 ;254
00002a  da0b              BGE      |L3.68|
00002c  4611              MOV      r1,r2                 ;254
                  |L3.46|
00002e  2c02              CMP      r4,#2                 ;258
000030  daf6              BGE      |L3.32|
000032  fb01f401          MUL      r4,r1,r1              ;258
000036  fb004200          MLA      r2,r0,r0,r4           ;261
00003a  ebb30f62          CMP      r3,r2,ASR #1          ;261
00003e  dae8              BGE      |L3.18|
000040  4608              MOV      r0,r1                 ;262
000042  bd30              POP      {r4,r5,pc}
                  |L3.68|
000044  4610              MOV      r0,r2                 ;256
000046  dcf2              BGT      |L3.46|
000048  bd30              POP      {r4,r5,pc}
;;;267    
                          ENDP


                          AREA ||i.get_circle_X||, CODE, READONLY, ALIGN=1

                  get_circle_X PROC
;;;18     
;;;19     s32 get_circle_X(s32 a, s32 radius) {
000000  b510              PUSH     {r4,lr}
;;;20     	a *= 10;
000002  eb000080          ADD      r0,r0,r0,LSL #2
000006  460c              MOV      r4,r1                 ;19
000008  0040              LSLS     r0,r0,#1
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f5006061          ADD      r0,r0,#0xe10          ;19
                  |L4.16|
;;;21     	while (a < 0)	a += 3600;
000010  2800              CMP      r0,#0
000012  dbfb              BLT      |L4.12|
;;;22     	while (a > 3600) a -= 3600;
000014  f44f6161          MOV      r1,#0xe10
                  |L4.24|
000018  4288              CMP      r0,r1
00001a  dd02              BLE      |L4.34|
00001c  f5a06061          SUB      r0,r0,#0xe10
000020  e7fa              B        |L4.24|
                  |L4.34|
;;;23     
;;;24     	return (radius * int_cos(a) / 10000); // (rcosT)
000022  f7fffffe          BL       int_cos
000026  4360              MULS     r0,r4,r0
000028  f2427110          MOV      r1,#0x2710
00002c  fb90f0f1          SDIV     r0,r0,r1
;;;25     	
;;;26     }
000030  bd10              POP      {r4,pc}
;;;27     
                          ENDP


                          AREA ||i.get_circle_Y||, CODE, READONLY, ALIGN=1

                  get_circle_Y PROC
;;;27     
;;;28     s32 get_circle_Y(s32 a, s32 radius) {
000000  b510              PUSH     {r4,lr}
;;;29     	a *= 10;
000002  eb000080          ADD      r0,r0,r0,LSL #2
000006  460c              MOV      r4,r1                 ;28
000008  0040              LSLS     r0,r0,#1
00000a  e001              B        |L5.16|
                  |L5.12|
00000c  f5006061          ADD      r0,r0,#0xe10          ;28
                  |L5.16|
;;;30     	while (a < 0)	a += 3600;
000010  2800              CMP      r0,#0
000012  dbfb              BLT      |L5.12|
;;;31     	while (a > 3600) a -= 3600;
000014  f44f6161          MOV      r1,#0xe10
                  |L5.24|
000018  4288              CMP      r0,r1
00001a  dd02              BLE      |L5.34|
00001c  f5a06061          SUB      r0,r0,#0xe10
000020  e7fa              B        |L5.24|
                  |L5.34|
;;;32     
;;;33     	return (radius * int_sin(a) / 10000);	// rsinT
000022  f7fffffe          BL       int_sin
000026  4360              MULS     r0,r4,r0
000028  f2427110          MOV      r1,#0x2710
00002c  fb90f0f1          SDIV     r0,r0,r1
;;;34     	
;;;35     }
000030  bd10              POP      {r4,pc}
;;;36     
                          ENDP


                          AREA ||i.int_arc_cos||, CODE, READONLY, ALIGN=1

                  int_arc_cos PROC
;;;139      */
;;;140    s16 int_arc_cos(s16 cos_val)
000000  b500              PUSH     {lr}
;;;141    {
;;;142    	return 90-int_arc_sin(cos_val);
000002  f7fffffe          BL       int_arc_sin
000006  f1c0005a          RSB      r0,r0,#0x5a
00000a  b200              SXTH     r0,r0
;;;143    }
00000c  bd00              POP      {pc}
;;;144    
                          ENDP


                          AREA ||i.int_arc_sin||, CODE, READONLY, ALIGN=1

                  int_arc_sin PROC
;;;99       */
;;;100    s16 int_arc_sin(s16 sin_val)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;101    {
;;;102    	s32 search_angle = 0;
;;;103    
;;;104    	s16 lower_bound = 0, upper_bound = 900;
000004  2500              MOVS     r5,#0
000006  f44f7961          MOV      r9,#0x384
;;;105    	s16 interval = 450, index = 0;
00000a  f44f76e1          MOV      r6,#0x1c2
;;;106    	u8 neg_val = 0;
00000e  462f              MOV      r7,r5
;;;107    
;;;108    
;;;109    	if (sin_val < 0)	neg_val = 1;
000010  2800              CMP      r0,#0
000012  da01              BGE      |L7.24|
000014  2701              MOVS     r7,#1
;;;110    	sin_val = Abs(sin_val);
000016  4240              RSBS     r0,r0,#0
                  |L7.24|
000018  fa0ff880          SXTH     r8,r0
                  |L7.28|
;;;111    
;;;112    	while (1)
;;;113    	{
;;;114    		index = lower_bound + interval;
00001c  19a8              ADDS     r0,r5,r6
00001e  b204              SXTH     r4,r0
;;;115    		search_angle = int_sin(index);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       int_sin
;;;116    
;;;117    		if (interval == 0 || sin_val == search_angle)
000026  b10e              CBZ      r6,|L7.44|
000028  4580              CMP      r8,r0
00002a  d10d              BNE      |L7.72|
                  |L7.44|
;;;118    		{
;;;119    			index = (index+4)/10;
00002c  f04f000a          MOV      r0,#0xa
000030  f1040404          ADD      r4,r4,#4
000034  fb94f0f0          SDIV     r0,r4,r0
000038  b200              SXTH     r0,r0
;;;120    			break;
00003a  2f00              CMP      r7,#0
00003c  d002              BEQ      |L7.68|
;;;121    		}
;;;122    		else if (sin_val < search_angle)
;;;123    			upper_bound = index;
;;;124    		else//						(sin_val > search_angle)
;;;125    			lower_bound = index;
;;;126    		interval = (upper_bound - lower_bound) / 2;
;;;127    
;;;128    	}
;;;129    
;;;130    	if (neg_val)	return -index;
00003e  f1c00000          RSB      r0,r0,#0
000042  b200              SXTH     r0,r0
                  |L7.68|
;;;131    	else			return index;
;;;132    }
000044  e8bd83f0          POP      {r4-r9,pc}
                  |L7.72|
000048  da01              BGE      |L7.78|
00004a  46a1              MOV      r9,r4                 ;123
00004c  e000              B        |L7.80|
                  |L7.78|
00004e  4625              MOV      r5,r4                 ;125
                  |L7.80|
000050  eba90005          SUB      r0,r9,r5              ;126
000054  eb0070d0          ADD      r0,r0,r0,LSR #31      ;126
000058  f340064f          SBFX     r6,r0,#1,#16          ;126
00005c  e7de              B        |L7.28|
;;;133    
                          ENDP


                          AREA ||i.int_arc_tan||, CODE, READONLY, ALIGN=1

                  int_arc_tan PROC
;;;149      */
;;;150    s16 int_arc_tan(s32 tan_val)
000000  b5f0              PUSH     {r4-r7,lr}
;;;151    {
000002  0006              MOVS     r6,r0
;;;152    	s16 angle = 0;
000004  f04f0500          MOV      r5,#0
;;;153    	s16 pre_tan = 0;
;;;154    	s16 cur_tan = 0;
000008  4628              MOV      r0,r5
00000a  d41a              BMI      |L8.66|
                  |L8.12|
;;;155    	if (tan_val >= 0) {
;;;156    		while (angle < 90) {
;;;157    			pre_tan = cur_tan;
00000c  4604              MOV      r4,r0
;;;158    			cur_tan = int_tan(angle);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       int_tan
;;;159    			if (tan_val <= cur_tan && tan_val >= pre_tan) break;
000014  4286              CMP      r6,r0
000016  dc01              BGT      |L8.28|
000018  42a6              CMP      r6,r4
00001a  da10              BGE      |L8.62|
                  |L8.28|
00001c  1c6d              ADDS     r5,r5,#1
;;;160    			angle++;
00001e  b22d              SXTH     r5,r5
000020  2d5a              CMP      r5,#0x5a              ;156
000022  dbf3              BLT      |L8.12|
000024  e00b              B        |L8.62|
                  |L8.38|
;;;161    		}
;;;162    	} else {
;;;163    		while (angle >= -89) {
;;;164    			pre_tan = cur_tan;
000026  4604              MOV      r4,r0
;;;165    			cur_tan = int_tan(angle);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       int_tan
;;;166    			if (tan_val >= cur_tan && tan_val <= pre_tan) break;
00002e  4286              CMP      r6,r0
000030  db01              BLT      |L8.54|
000032  42a6              CMP      r6,r4
000034  dd03              BLE      |L8.62|
                  |L8.54|
000036  1e6d              SUBS     r5,r5,#1
;;;167    			angle--;
000038  b22d              SXTH     r5,r5
00003a  42bd              CMP      r5,r7                 ;163
00003c  daf3              BGE      |L8.38|
                  |L8.62|
;;;168    		}
;;;169    	}
;;;170    	return angle;
00003e  4628              MOV      r0,r5
;;;171    }
000040  bdf0              POP      {r4-r7,pc}
                  |L8.66|
000042  f06f0758          MVN      r7,#0x58              ;163
000046  e7ee              B        |L8.38|
;;;172    
                          ENDP


                          AREA ||i.int_arc_tan2||, CODE, READONLY, ALIGN=1

                  int_arc_tan2 PROC
;;;178      */
;;;179    s16 int_arc_tan2(s32 y, s32 x)
000000  b500              PUSH     {lr}
;;;180    {
000002  b179              CBZ      r1,|L9.36|
;;;181    	if (x == 0) {
;;;182    		if (y < 0)
;;;183    			return -90;
;;;184    		else if (y == 0)
;;;185    			return 0;
;;;186    		else
;;;187    			return 90;
;;;188    	} else if (y == 0) {
000004  b1b8              CBZ      r0,|L9.54|
;;;189    		return x < 0 ? 180 : 0;
;;;190    	} else if (x < 0) {
;;;191    		return 180+int_arc_tan((s32)(100*y+x/2)/x);
000006  2264              MOVS     r2,#0x64
000008  4350              MULS     r0,r2,r0
00000a  eb0172d1          ADD      r2,r1,r1,LSR #31
00000e  eb000062          ADD      r0,r0,r2,ASR #1
;;;192    	} else {
;;;193    		return int_arc_tan((s32)(100*y+x/2)/x);
000012  fb90f0f1          SDIV     r0,r0,r1
000016  2900              CMP      r1,#0                 ;190
000018  da13              BGE      |L9.66|
00001a  f7fffffe          BL       int_arc_tan
00001e  30b4              ADDS     r0,r0,#0xb4           ;191
000020  b200              SXTH     r0,r0                 ;191
;;;194    	}
;;;195    }
000022  bd00              POP      {pc}
                  |L9.36|
000024  2800              CMP      r0,#0                 ;182
000026  da02              BGE      |L9.46|
000028  f06f0059          MVN      r0,#0x59              ;183
00002c  bd00              POP      {pc}
                  |L9.46|
00002e  d006              BEQ      |L9.62|
000030  f04f005a          MOV      r0,#0x5a              ;187
000034  bd00              POP      {pc}
                  |L9.54|
000036  2900              CMP      r1,#0                 ;189
000038  da01              BGE      |L9.62|
00003a  20b4              MOVS     r0,#0xb4              ;189
00003c  bd00              POP      {pc}
                  |L9.62|
00003e  2000              MOVS     r0,#0                 ;189
000040  bd00              POP      {pc}
                  |L9.66|
000042  f85deb04          POP      {lr}                  ;193
000046  f7ffbffe          B.W      int_arc_tan
;;;196    
                          ENDP


                          AREA ||i.int_cos||, CODE, READONLY, ALIGN=1

                  int_cos PROC
;;;65       */
;;;66     s32 int_cos(s32 a)
000000  f5c07061          RSB      r0,r0,#0x384
;;;67     {
;;;68     	return int_sin(900-a);
000004  f7ffbffe          B.W      int_sin
;;;69     }
;;;70     
                          ENDP


                          AREA ||i.int_sin||, CODE, READONLY, ALIGN=2

                  int_sin PROC
;;;42       */
;;;43     s32 int_sin(s32 a)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
;;;45     	s16 ta;
;;;46     	while(a < 0)
;;;47     		a += 3600;
000002  e001              B        |L11.8|
                  |L11.4|
000004  f5006061          ADD      r0,r0,#0xe10
                  |L11.8|
000008  2800              CMP      r0,#0                 ;46
00000a  dbfb              BLT      |L11.4|
;;;48     	a = a % 3600;
00000c  f44f6161          MOV      r1,#0xe10
000010  fb90f2f1          SDIV     r2,r0,r1
000014  fb010012          MLS      r0,r1,r2,r0
;;;49     	ta = a;
;;;50     	if (a > 2700) {
000018  f640218c          MOV      r1,#0xa8c
00001c  b202              SXTH     r2,r0                 ;49
;;;51     		a = 3600-a;
;;;52     	} else if (a > 1800) {
00001e  f44f65e1          MOV      r5,#0x708
000022  4288              CMP      r0,r1                 ;50
000024  dd02              BLE      |L11.44|
000026  f5c06061          RSB      r0,r0,#0xe10          ;51
00002a  e009              B        |L11.64|
                  |L11.44|
00002c  42a8              CMP      r0,r5
00002e  dd02              BLE      |L11.54|
000030  f5a060e1          SUB      r0,r0,#0x708
;;;53     		a = a-1800;
000034  e004              B        |L11.64|
                  |L11.54|
;;;54     	} else if (a > 900) {
000036  f5b07f61          CMP      r0,#0x384
00003a  dd01              BLE      |L11.64|
;;;55     		a = 1800-a;
00003c  f5c060e1          RSB      r0,r0,#0x708
                  |L11.64|
;;;56     	}
;;;57     	a = cos_val[90-(a/10)] + (((a%10)*cos_val[a/10]+286)/573);
000040  210a              MOVS     r1,#0xa
000042  fb90f3f1          SDIV     r3,r0,r1
000046  f1c3045a          RSB      r4,r3,#0x5a
00004a  4b0b              LDR      r3,|L11.120|
00004c  f9336014          LDRSH    r6,[r3,r4,LSL #1]
000050  fb90f4f1          SDIV     r4,r0,r1
000054  fb010414          MLS      r4,r1,r4,r0
000058  fb90f0f1          SDIV     r0,r0,r1
00005c  f9330010          LDRSH    r0,[r3,r0,LSL #1]
000060  4344              MULS     r4,r0,r4
000062  f240203d          MOV      r0,#0x23d
000066  f504748f          ADD      r4,r4,#0x11e
00006a  fb94f0f0          SDIV     r0,r4,r0
00006e  4430              ADD      r0,r0,r6
;;;58     	return ta > 1800 ? -a : a;
000070  42aa              CMP      r2,r5
000072  dd00              BLE      |L11.118|
000074  4240              RSBS     r0,r0,#0
                  |L11.118|
;;;59     }
000076  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

                  |L11.120|
                          DCD      ||.data||+0xb6

                          AREA ||i.int_tan||, CODE, READONLY, ALIGN=2

                  int_tan PROC
;;;75       */
;;;76     s16 int_tan(s16 a)
000000  2100              MOVS     r1,#0
;;;77     {
;;;78     	u8 neg = 0;
;;;79     	if (a < 0) {
000002  2800              CMP      r0,#0
000004  da06              BGE      |L12.20|
;;;80     		neg = 1;
000006  2101              MOVS     r1,#1
;;;81     		a = -a;
000008  4240              RSBS     r0,r0,#0
00000a  e000              B        |L12.14|
                  |L12.12|
00000c  30b4              ADDS     r0,r0,#0xb4
                  |L12.14|
00000e  b200              SXTH     r0,r0
;;;82     	}
;;;83     	while (a < 0)
000010  2800              CMP      r0,#0
000012  dbfb              BLT      |L12.12|
                  |L12.20|
;;;84     		a += 180;
;;;85     	a = a % 180;
000014  22b4              MOVS     r2,#0xb4
000016  fb90f3f2          SDIV     r3,r0,r2
00001a  fb020013          MLS      r0,r2,r3,r0
;;;86     	if (a > 90) {
;;;87     		return neg ? tan_val[180-a] : -tan_val[180-a];
00001e  4a0a              LDR      r2,|L12.72|
000020  285a              CMP      r0,#0x5a              ;86
000022  dd03              BLE      |L12.44|
000024  f1c000b4          RSB      r0,r0,#0xb4
000028  b939              CBNZ     r1,|L12.58|
00002a  e001              B        |L12.48|
                  |L12.44|
;;;88     	} else if (a < 90) {
00002c  da09              BGE      |L12.66|
;;;89     		return neg ? -tan_val[a] : tan_val[a];
00002e  b121              CBZ      r1,|L12.58|
                  |L12.48|
000030  f9320010          LDRSH    r0,[r2,r0,LSL #1]
000034  f1c00000          RSB      r0,r0,#0
000038  e001              B        |L12.62|
                  |L12.58|
00003a  f9320010          LDRSH    r0,[r2,r0,LSL #1]
                  |L12.62|
00003e  b200              SXTH     r0,r0
;;;90     	} else {
;;;91     		return -1;
;;;92     	}
;;;93     }
000040  4770              BX       lr
                  |L12.66|
000042  f04f30ff          MOV      r0,#0xffffffff        ;91
000046  4770              BX       lr
;;;94     
                          ENDP

                  |L12.72|
                          DCD      ||.data||

                          AREA ||i.p_mod||, CODE, READONLY, ALIGN=1

                  p_mod PROC
;;;209    
;;;210    s32 p_mod(s32 dividor, s32 divisor) {
000000  e000              B        |L13.4|
                  |L13.2|
;;;211    		while (dividor < 0) {dividor += divisor;}
000002  4408              ADD      r0,r0,r1
                  |L13.4|
000004  2800              CMP      r0,#0
000006  dbfc              BLT      |L13.2|
;;;212    		return dividor % divisor;
000008  fb90f2f1          SDIV     r2,r0,r1
00000c  fb010012          MLS      r0,r1,r2,r0
;;;213    }
000010  4770              BX       lr
;;;214    
                          ENDP


                          AREA ||i.s_Abs||, CODE, READONLY, ALIGN=1

                  s_Abs PROC
;;;224    
;;;225    s32 s_Abs (s32 v) {
000000  2800              CMP      r0,#0
000002  da00              BGE      |L14.6|
;;;226    	return v < 0 ? -v : v;
000004  4240              RSBS     r0,r0,#0
                  |L14.6|
;;;227    }
000006  4770              BX       lr
;;;228    
                          ENDP


                          AREA ||i.xy_rotate||, CODE, READONLY, ALIGN=1

                  xy_rotate PROC
;;;201      */
;;;202    void xy_rotate(s32 *x, s32 *y, s32 w) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;203    	s32 new_x = int_cos(w) * *x - int_sin(w) * *y;
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       int_cos
000010  6829              LDR      r1,[r5,#0]
000012  fb00f601          MUL      r6,r0,r1
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       int_sin
00001c  6821              LDR      r1,[r4,#0]
00001e  fb006611          MLS      r6,r0,r1,r6
;;;204    	s32 new_y = int_sin(w) * *x + int_cos(w) * *y;
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       int_sin
000028  6829              LDR      r1,[r5,#0]
00002a  fb00f701          MUL      r7,r0,r1
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       int_cos
000034  6821              LDR      r1,[r4,#0]
000036  fb007001          MLA      r0,r0,r1,r7
;;;205    	*x = new_x / 10000;
00003a  f2427110          MOV      r1,#0x2710
00003e  fb96f2f1          SDIV     r2,r6,r1
;;;206    	*y = new_y / 10000;
000042  fb90f0f1          SDIV     r0,r0,r1
000046  602a              STR      r2,[r5,#0]
000048  6020              STR      r0,[r4,#0]
;;;207    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;208    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  tan_val
000000  00000002          DCW      0x0000,0x0002
000004  00030005          DCW      0x0003,0x0005
000008  00070009          DCW      0x0007,0x0009
00000c  000b000c          DCW      0x000b,0x000c
000010  000e0010          DCW      0x000e,0x0010
000014  00120013          DCW      0x0012,0x0013
000018  00150017          DCW      0x0015,0x0017
00001c  0019001b          DCW      0x0019,0x001b
000020  001d001f          DCW      0x001d,0x001f
000024  00200022          DCW      0x0020,0x0022
000028  00240026          DCW      0x0024,0x0026
00002c  0028002a          DCW      0x0028,0x002a
000030  002d002f          DCW      0x002d,0x002f
000034  00310033          DCW      0x0031,0x0033
000038  00350037          DCW      0x0035,0x0037
00003c  003a003c          DCW      0x003a,0x003c
000040  003e0041          DCW      0x003e,0x0041
000044  00430046          DCW      0x0043,0x0046
000048  0049004b          DCW      0x0049,0x004b
00004c  004e0051          DCW      0x004e,0x0051
000050  00540057          DCW      0x0054,0x0057
000054  005a005d          DCW      0x005a,0x005d
000058  00610064          DCW      0x0061,0x0064
00005c  0068006b          DCW      0x0068,0x006b
000060  006f0073          DCW      0x006f,0x0073
000064  0077007b          DCW      0x0077,0x007b
000068  00800085          DCW      0x0080,0x0085
00006c  008a008f          DCW      0x008a,0x008f
000070  0094009a          DCW      0x0094,0x009a
000074  00a000a6          DCW      0x00a0,0x00a6
000078  00ad00b4          DCW      0x00ad,0x00b4
00007c  00bc00c4          DCW      0x00bc,0x00c4
000080  00cd00d6          DCW      0x00cd,0x00d6
000084  00e100ec          DCW      0x00e1,0x00ec
000088  00f80105          DCW      0x00f8,0x0105
00008c  01130122          DCW      0x0113,0x0122
000090  01340147          DCW      0x0134,0x0147
000094  015d0175          DCW      0x015d,0x0175
000098  019101b1          DCW      0x0191,0x01b1
00009c  01d60202          DCW      0x01d6,0x0202
0000a0  02370277          DCW      0x0237,0x0277
0000a4  02c8032e          DCW      0x02c8,0x032e
0000a8  03b70477          DCW      0x03b7,0x0477
0000ac  05960774          DCW      0x0596,0x0774
0000b0  0b301661          DCW      0x0b30,0x1661
0000b4  0000              DCB      0x00,0x00
                  cos_val
0000b6  2710              DCW      0x2710
0000b8  270e270a          DCW      0x270e,0x270a
0000bc  270226f8          DCW      0x2702,0x26f8
0000c0  26ea26d9          DCW      0x26ea,0x26d9
0000c4  26c526af          DCW      0x26c5,0x26af
0000c8  26952678          DCW      0x2695,0x2678
0000cc  26582635          DCW      0x2658,0x2635
0000d0  261025e7          DCW      0x2610,0x25e7
0000d4  25bb258d          DCW      0x25bb,0x258d
0000d8  255b2527          DCW      0x255b,0x2527
0000dc  24ef24b5          DCW      0x24ef,0x24b5
0000e0  24782438          DCW      0x2478,0x2438
0000e4  23f523af          DCW      0x23f5,0x23af
0000e8  2367231c          DCW      0x2367,0x231c
0000ec  22ce227d          DCW      0x22ce,0x227d
0000f0  222a21d4          DCW      0x222a,0x21d4
0000f4  217c2120          DCW      0x217c,0x2120
0000f8  20c32062          DCW      0x20c3,0x2062
0000fc  20001f9a          DCW      0x2000,0x1f9a
000100  1f321ec8          DCW      0x1f32,0x1ec8
000104  1e5b1dec          DCW      0x1e5b,0x1dec
000108  1d7b1d07          DCW      0x1d7b,0x1d07
00010c  1c921c19          DCW      0x1c92,0x1c19
000110  1b9f1b23          DCW      0x1b9f,0x1b23
000114  1aa41a23          DCW      0x1aa4,0x1a23
000118  19a1191c          DCW      0x19a1,0x191c
00011c  1895180d          DCW      0x1895,0x180d
000120  178216f6          DCW      0x1782,0x16f6
000124  166815d8          DCW      0x1668,0x15d8
000128  154614b3          DCW      0x1546,0x14b3
00012c  141e1388          DCW      0x141e,0x1388
000130  12f01257          DCW      0x12f0,0x1257
000134  11bc1120          DCW      0x11bc,0x1120
000138  10820fe3          DCW      0x1082,0x0fe3
00013c  0f430ea2          DCW      0x0f43,0x0ea2
000140  0e000d5c          DCW      0x0e00,0x0d5c
000144  0cb80c12          DCW      0x0cb8,0x0c12
000148  0b6c0ac4          DCW      0x0b6c,0x0ac4
00014c  0a1c0973          DCW      0x0a1c,0x0973
000150  08ca081f          DCW      0x08ca,0x081f
000154  077406c8          DCW      0x0774,0x06c8
000158  061c0570          DCW      0x061c,0x0570
00015c  04c30415          DCW      0x04c3,0x0415
000160  036802ba          DCW      0x0368,0x02ba
000164  020b015d          DCW      0x020b,0x015d
000168  00af0000          DCW      0x00af,0x0000
