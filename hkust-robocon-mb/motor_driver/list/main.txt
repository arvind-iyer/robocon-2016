; generated by Component: ARM Compiler 5.06 (build 20) Tool: ArmCC [4d35a4]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931 -I.\FWlib\inc -I.\user -IC:\Users\BudiRyan\Documents\GitHub\robocon-2016\hkust-robocon-mb\motor_driver\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=516 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\main.crf user\main.c]
                          THUMB

                          AREA ||i.life_signal||, CODE, READONLY, ALIGN=1

                  life_signal PROC
;;;25     	*/
;;;26     void life_signal(void)
000000  b510              PUSH     {r4,lr}
;;;27     {
;;;28     	if (get_seconds() % 2) {
000002  f7fffffe          BL       get_seconds
000006  07c0              LSLS     r0,r0,#31
000008  d005              BEQ      |L1.22|
;;;29     		led_control(LED_1, LED_ON);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       led_control
;;;30     		led_control(LED_2, LED_OFF);
000012  2100              MOVS     r1,#0
000014  e004              B        |L1.32|
                  |L1.22|
;;;31     	} else {
;;;32     		led_control(LED_1, LED_OFF);
000016  2100              MOVS     r1,#0
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       led_control
;;;33     		led_control(LED_2, LED_ON);
00001e  2101              MOVS     r1,#1
                  |L1.32|
000020  e8bd4010          POP      {r4,lr}
000024  2002              MOVS     r0,#2
000026  f7ffbffe          B.W      led_control
;;;34     	}
;;;35     }
;;;36     
                          ENDP


                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;36     
;;;37     int main(void)
000000  f2413088          MOV      r0,#0x1388
;;;38     {
;;;39     	/** initialization **/
;;;40     	system_init(5000);
000004  f7fffffe          BL       system_init
;;;41     	ticks_init();
000008  f7fffffe          BL       ticks_init
;;;42     	led_init();
00000c  f7fffffe          BL       led_init
;;;43     	encoder_init(); 
000010  f7fffffe          BL       encoder_init
;;;44     	motor_init();
000014  f7fffffe          BL       motor_init
;;;45     	can_init();
000018  f7fffffe          BL       can_init
;;;46     	can_rx_init();
00001c  f7fffffe          BL       can_rx_init
;;;47     	can_motor_init();
000020  f7fffffe          BL       can_motor_init
;;;48     	uart_init(COM1, 115200);
000024  f44f31e1          MOV      r1,#0x1c200
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       uart_init
;;;49     	uart_printf_enable(COM1);
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       uart_printf_enable
;;;50     	/** end of init **/
;;;51     
;;;52     	while (true) {
;;;53     		if (ticks_img != get_ticks()) {
;;;54     			ticks_img = get_ticks();
;;;55     			/** 1000Hz, can be higher by using systicks instead **/
;;;56     			encoder_update();
;;;57     			/** Depends on acceleration value to accelerate **/
;;;58     			if (ticks_img % (1000 / get_current_accel()) == 0) {
000034  f44f757a          MOV      r5,#0x3e8
000038  4c12              LDR      r4,|L2.132|
;;;59     				velocity_update();
;;;60     			}
;;;61     			/** end of motor control **/
;;;62     			if (ticks_img % 100 == 0) {
00003a  2664              MOVS     r6,#0x64
                  |L2.60|
00003c  f7fffffe          BL       get_ticks
000040  8821              LDRH     r1,[r4,#0]            ;53  ; ticks_img
000042  4288              CMP      r0,r1                 ;53
000044  d0fa              BEQ      |L2.60|
000046  f7fffffe          BL       get_ticks
00004a  8020              STRH     r0,[r4,#0]            ;54
00004c  f7fffffe          BL       encoder_update
000050  f7fffffe          BL       get_current_accel
000054  fbb5f0f0          UDIV     r0,r5,r0              ;58
000058  8821              LDRH     r1,[r4,#0]            ;58  ; ticks_img
00005a  fbb1f2f0          UDIV     r2,r1,r0              ;58
00005e  fb001012          MLS      r0,r0,r2,r1           ;58
000062  b908              CBNZ     r0,|L2.104|
000064  f7fffffe          BL       velocity_update
                  |L2.104|
000068  8820              LDRH     r0,[r4,#0]  ; ticks_img
00006a  fbb0f1f6          UDIV     r1,r0,r6
00006e  fb060011          MLS      r0,r6,r1,r0
000072  b918              CBNZ     r0,|L2.124|
;;;63     				send_encoder(get_encoder());
000074  f7fffffe          BL       get_encoder
000078  f7fffffe          BL       send_encoder
                  |L2.124|
;;;64     			}
;;;65     			
;;;66     #ifdef DEBUG_MODE	// In debug mode, for hardware to debug by themselves
;;;67     			debug();
00007c  f7fffffe          BL       debug
000080  e7dc              B        |L2.60|
;;;68     #else							// Normal execute mode, led show life signal.
;;;69     			/** flahsing led light to show mcu still working **/
;;;70     			if (!FULL_SPEED_LIMIT) {
;;;71     				life_signal();
;;;72     			} else {
;;;73     				led_control(LED_BOTH, LED_ON);
;;;74     			}
;;;75     #endif
;;;76     		}
;;;77     	}
;;;78     }
;;;79     
                          ENDP

000082  0000              DCW      0x0000
                  |L2.132|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=1

                  ticks_img
000000  ffff              DCW      0xffff

                  __ARM_use_no_argv EQU 0
